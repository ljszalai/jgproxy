<html>
<head>
<title>&lt;&lt;---[Proxy Server] --&gt;&gt;</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
</head>

<body bgcolor="#FFFFFF">
<table width="100%" border="0" height="504" vspace="0" hspace="0" align="center">
  <tr valign="top"> 
    <td height="150"> 
      <div align="center"> 
        <p><font size="3"><b><font size="7">Java Proxy Server <font size="3"><b><font size="4">&reg;</font></b></font><font size="5"><br>
          v. 1.0</font></font></b></font> </p>
      </div>
    </td>
  </tr>
  <tr valign="top"> 
    <td height="232"> 
      <p><font size="5"><b><u><font size="4">Introduction: </font></u></b></font></p>
      <blockquote> 
        <p>A proxy server is basically an intermediary forwarding station between 
          two computers, a client and a server.<br>
          The way that it works is fairly simple and straightforward. The proxy 
          server sits and waits, listening to a particular port on the local machine 
          where it is running. Once a request is made to that port, the proxy 
          then establishes a connection to a specified port on a specified remote 
          host. <br>
          Any data transfered from the client to the proxy is forwarded from the 
          proxy to the remote host. Likewise, any responses recieved from the 
          remote host by the proxy are forwarded to the client. In this way, the 
          proxy server acts as a &quot;middle man&quot; between the client and 
          the remote host. It recieves all the data from each, and forwards it 
          to the other. <br>
          Both the client and the remote host have no idea that the proxy is between 
          them, as it is invisible to each. They send their requests and responses, 
          and the proxy takes care of the connections between both. <br>
          As such, the proxy must act as both a client and a server. It is a server 
          to the original client requesting data from the remote host. The proxy 
          intercepts this request as if it were the server, and then sends this 
          same request to the remote host, acting as if it were a client. When 
          the remote host sends it's response, the proxy recieves it as a client, 
          and then send it to the client as if it were the server.</p>
      </blockquote>
    </td>
  </tr>
  <tr valign="top"> 
    <td height="1449"> 
      <p><font size="5"><b><u><font size="4">Theory of Operation: </font></u></b></font></p>
      <blockquote> 
        <p align="left">The stand-alone Java TCP proxy called "proxy.java", will 
          correctly do the following:</p>
        <ul>
          <li> 
            <div align="center"> 
              <div align="left">Read the local port, remote machine name and remote 
                port as command line arguments (in that order). </div>
            </div>
          </li>
          <li> 
            <div align="center"> 
              <div align="left">Create a socket and accept TCP requests on the 
                local port. </div>
            </div>
          </li>
          <li> 
            <div align="center"> 
              <div align="left">Create a socket and connect to the remote machine's 
                remote TCP port. </div>
            </div>
          </li>
          <li> 
            <div align="center"> 
              <div align="left">Create two threads, one to handle each of the 
                following: </div>
            </div>
            <ul>
              <li> 
                <div align="center"> 
                  <div align="left">Read an unknown amount data from the local 
                    port and forward it to the remote port</div>
                </div>
              </li>
              <li> 
                <div align="center"> 
                  <div align="left">Read an unknown amount of data from the remote 
                    port and forward it to the local port.</div>
                </div>
              </li>
            </ul>
          </li>
          <li> 
            <div align="center"> 
              <div align="left">Close the sockets if either closes or an exception 
                occurs.</div>
            </div>
          </li>
          <li> 
            <div align="center"> 
              <div align="left">Correctly terminate the threads. </div>
            </div>
          </li>
          <li> 
            <div align="center"> 
              <div align="left">After the sockets are closed, connect more clients 
                without re-starting the proxy. </div>
            </div>
          </li>
          <li>Complete each of these tasks for multiple concurrent users.</li>
        </ul>
        <p>Each of these tasks was implemented entirely in Java, and can be run 
          on any machine which supports Java. The following is a detailed description 
          of how each was accomplished:</p>
      </blockquote>
      <ul>
        <li><b>Read the local port, remote machine name and remote port as command 
          line arguments (in that order):</b> 
          <blockquote> 
            <p>This was done by by parsing the commands entered by the user when 
              the Proxy Server was initailly started, picking off each peice. 
              The local port number was parsed first, followed by the remote host 
              name, and finaly the remote port address. Each of these were checked 
              for legality, and passed to the rest of the program if acceptable. 
              If any were invalid, the program would exit and report the appropriate 
              error.</p>
          </blockquote>
        </li>
        <li><b>Create a socket and accept TCP requests on the local port:</b> 
          <blockquote> 
            <p>This was accomplished by creating a new Server Socket Server, from 
              the ServerSocket Class. The port which it listens on is the one 
              passed by the user on the command line. An Accepting socket was 
              cxreated by using the Accept() method of the Server Socket Class. 
              This port was now ready to begin accepting TCP requests.</p>
          </blockquote>
        </li>
        <li><b>Create two threads:</b> 
          <blockquote> 
            <p>This was done by implementing a new Class, proxyThread which extends 
              the Thread Class, and creating 2 new proxyThreads, which accept 
              Sockets as their parameters. The Sockets that are passed are the 
              Incoming and Outgoing Sockets, in that order. The Run() method of 
              the Thread Class is overwritten, and does the actual data stream 
              transferring, by the use of the OutputStream object, and the IpnutStream 
              object of the Socket Class. The Proxy accepts data on the InputStream 
              with the use of the Read() method, and stores it in a buffer. It 
              then sends this buffer on the OutputStream with the use of the Write() 
              methods of that sream. </p>
          </blockquote>
        </li>
        <ul>
          <li><b>One to handle each of the following:</b></li>
        </ul>
        <blockquote> 
          <p><br>
            <b>Read an unknown amount data from the local port and forward it 
            to the remote port:</b></p>
          <p>This was done by passing the incoming<b> </b>and outgoing port (in 
            that order) to the proxyThread constructor. This creates a Listening 
            Socket on the Proxy Server, listening on the local port, and a Sending 
            Socket, directed to the Server who is serving the requests. The amount 
            of data read at each instant is printed to the screen where the proxy 
            is running.<b><br>
            <br>
            Read an unknown amount of data from the remote port and forward it 
            to the local port.</b></p>
          <p>In this case, the proxyThread class was sent the Socket parameters 
            in the reverse order. The Listening Socket (first parameter) was the 
            socket connected to the Server, and the Sending Socket (second parameter) 
            was connected to the local port of the Client. The amount of data 
            read at each instant is printed to the screen where the proxy is running.</p>
        </blockquote>
        <li><b>Close the sockets if either closes or an exception occurs:</b> 
          <blockquote> 
            <p>If any type of error is detected while the server is either started 
              or running, it will immediately close all sockets, and terminate 
              itself. If either the Client or the Server close their connections 
              to the other, the Proxy Server will also close all sockets and terminate 
              itseslf. It knows if either the Client or Server has disconnected 
              because a -1 is sent. The Proxy Server listens, waiting for this 
              to be sent, and when it is encountered, all sockets are closed.</p>
          </blockquote>
        </li>
        <li><b> Correctly terminate the threads:</b> 
          <blockquote> 
            <p>Again, if any type of error is detected while the server is either 
              started or running, it will immediately end all threads, and terminate 
              itself. If either the Client or the Server close their connections 
              to the other, the Proxy Server will also end all threads and terminate 
              itseslf. It knows if either the Client or Server has disconnected 
              because a -1 is sent. The Proxy Server listens, waiting for this 
              to be sent, and when it is encountered, all threads are closed.</p>
          </blockquote>
        </li>
        <li><b>After the sockets are closed, connect more clients without re-starting 
          the proxy:</b> 
          <blockquote> 
            <p>Once the server is started it will continualy listen for new connections 
              on the port it is listening to. Therefore, if one connection is 
              ended, thereby closing the sockets and terminating the threads, 
              the Proxy Server will still be active, listening for more users 
              to connect. It does not need to be restarted in order to be connected 
              to by more clients, because it runs independently, with or without 
              users currently using it.</p>
          </blockquote>
        </li>
        <li><b>Complete each of these tasks for multiple concurrent users:</b> 
          <blockquote> 
            <p>Because the server creates a new pair of threads for each client 
              which attempts to connect to it, it can support multiple concurrent 
              users simultaneously without any problem.</p>
          </blockquote>
        </li>
      </ul>
    </td>
  </tr>
  <tr valign="top"> 
    <td height="416"> 
      <p><font size="5"><b><u><font size="4">Java Class Description: </font></u></b></font></p>
      <ul>
        <li><b>The proxy Class (proxy.class)</b> </li>
        <blockquote> 
          <p>The proxy Class implements the Main () method of the program. It 
            accepts and parses the users input, while doing some basic error checking. 
            It then holds the basic information which the Proxy Server needs to 
            run in variables, i.e the local port, remote machine, and remote port. 
            It then creates the incoming Server Socket, outgoing Socket to the 
            remote host, and sets the Proxy listening on the specified port for 
            a client. When it detects a client, it creates 2 threads for that 
            particular client, one incoming, and one outgoing.</p>
        </blockquote>
        <li><b>The proxyThread Class (proxyThread.class)</b> </li>
        <blockquote> 
          <p>The proxyThread Class implements the actual threads which the Proxy 
            Server uses to send and recieve data both the Client and Server. It 
            does the writing to and reading from of data streams, and controls 
            the data flow from Client to Server, and vice versa. It starts the 
            actual movement of data on the threads with the use the Run() method 
            of the Thread Class, which contains the aforementioned functionalities.</p>
        </blockquote>
        <li><b>For Complete Code Click Below:</b> 
          <ul>
            <li><a href="/proxy.java">proxy.java</a></li>
            <li><a href="/proxy.class">proxy.class</a></li>
            <li><a href="/proxyThread.java">proxyThread.java</a></li>
            <li><a href="/proxyThread.class">proxyThread.class</a></li>
            <li><a href="/proxyServer.zip">Whole Thing zipped</a></li>
          </ul>
        </li>
      </ul>
    </td>
  </tr>
  <tr valign="top"> 
    <td height="2"> 
      <div align="center"> 
        <p align="center"><i><font face="Georgia, Times New Roman, Times, serif" size="1">&copy;2001 
          <a href="http://dwgold.com">Dan Goldberg</a><br>
          </font></i><i><font face="Georgia, Times New Roman, Times, serif" size="1"> 
          All Rights Reserved</font></i></p>
        </div>
    </td>
  </tr>
</table>
</body>
</html>
